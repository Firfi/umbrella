// thing:no-export

// Downloaded @ 2023-02-20T22:42:01.250Z
// Source: https://demo.thi.ng/umbrella/parse-playground/#ldoKi0ROTDE6IDxETkw-KyA9PiBkaXNjYXJkIDsKRE5MMjogPE5MPnsyLH0gOwppbmxpbmVkZWxpbTogKCAiIVsiIHwgJ1snIHwgIioqIiB8ICdfJyB8ICJ-fiIgfCAnYCcgfCAiIDoiICkgOwpkZWxpbTogKCA8aW5saW5lZGVsaW0-IHwgPEROTDI-ICkgOwpkZWxpbTE6ICggPGlubGluZWRlbGltPiB8IDxOTD4gKSA7CmJvZHk6IC4oPy08ZGVsaW0-ISkgPT4gam9pbiA7CmJvZHkxOiAuKD8tPGRlbGltMT4hKSA9PiBqb2luIDsKCnJlZjogIltbIiEgLig_KyJdXSIhKSA9PiBqb2luIDsKZm5yZWY6ICJbXiIhIDx1aW50PiAiXSIhIDsKZm5vdGU6IDxMU1RBUlQ-ICJbXiIhIDx1aW50PiAiXToiISA8V1MxPiA8cGFyYT4gOwpsYWJlbDogLig_KyddJyEpID0-IGpvaW4gOwp0YXJnZXQ6IC4oPysnKSchKSA9PiBqb2luIDsKbGluazogJ1snISA8bGFiZWw-ICcoJyEgPHRhcmdldD4gOwpsaW5rcmVmOiAnWychIDxsYWJlbD4gJ1snISA8bGFiZWw-IDsKbGlua2RlZjogPExTVEFSVD4gJ1snISA8bGFiZWw-ICc6JyEgPFdTMT4gPGxkdGFyZ2V0PiA7CmxkdGFyZ2V0OiAuKD8rPEROTDE-KSA9PiBqb2luIDsKaW1nOiAiIVsiISA8bGFiZWw-ICcoJyEgPHRhcmdldD4gOwpib2xkOiAiKioiISAuKD8rIioqIiEpID0-IGpvaW4gOwppdGFsaWM6ICJfIiEgLig_KyJfIiEpID0-IGpvaW4gOwpjb2RlOiAnYCchIC4oPysnYCchKSA9PiBqb2luIDsKc3RyaWtlOiAifn4iISAuKD8rIn5-IiEpID0-IGpvaW4gOwplbW9qaTogJyAnPyAnOichIDxBTFBIQV9OVU0-KD8rJzonISkgPT4gam9pbiA7CnBhcmE6ICg8cmVmPiB8IDxpbWc-IHwgPGZucmVmPiB8IDxsaW5rcmVmPiB8IDxsaW5rPiB8IDxib2xkPiB8IDxpdGFsaWM-IHwgPHN0cmlrZT4gfCA8Y29kZT4gfCA8ZW1vamk-IHwgPGJvZHk-KSogPEROTDI-ISA7CgpoZGxldmVsOiAnIycrID0-IGNvdW50IDsKaGQ6IDxMU1RBUlQ-IDxoZGxldmVsPiA8V1MwPgogICAgKDxyZWY-IHwgPGltZz4gfCA8Zm5yZWY-IHwgPGxpbms-IHwgPGJvbGQ-IHwgPGl0YWxpYz4gfCA8c3RyaWtlPiB8IDxjb2RlPiB8IDxlbW9qaT4gfCA8Ym9keTE-ICkqIDxETkwxPiA7CgpsaWxldmVsOiAnICcqID0-IGNvdW50IDsKdWludDogPERJR0lUPisgPT4gaW50IDsKdWxpZDogPEROTD4gPFdTMD4gJy0nISA7Cm9saWQ6IDxETkw-IDxXUzA-IDxESUdJVD4rISAnLichIDsKbGlkZWxpbTogKCA8ZGVsaW0-IHwgPHVsaWQ-IHwgPG9saWQ-ICkgOwpsaWJvZHk6IC4oPy08bGlkZWxpbT4hKSA9PiBqb2luIDsKdG9kbzogJ1snISBbIHhYXSAnXSchIDxXUzE-ID0-IGhvaXN0UiA7CnVsaXRlbTogPExTVEFSVD4gPGxpbGV2ZWw-ICItICIhIDx0b2RvPj8KICAgICAgICAoPHJlZj4gfCA8aW1nPiB8IDxmbnJlZj4gfCA8bGluaz4gfCA8Ym9sZD4gfCA8aXRhbGljPiB8IDxzdHJpa2U-IHwgPGNvZGU-IHwgPGVtb2ppPiB8IDxsaWJvZHk-ICkqIDxETkw-IDsKb2xpdGVtOiA8TFNUQVJUPiA8bGlsZXZlbD4gPHVpbnQ-ICIuICIhIDx0b2RvPj8KICAgICAgICAoPHJlZj4gfCA8aW1nPiB8IDxmbnJlZj4gfCA8bGluaz4gfCA8Ym9sZD4gfCA8aXRhbGljPiB8IDxzdHJpa2U-IHwgPGNvZGU-IHwgPGVtb2ppPiB8IDxsaWJvZHk-ICkqIDxETkw-IDsKbGlzdDogKDx1bGl0ZW0-IHwgPG9saXRlbT4pKyA8RE5MMT4gOwoKY2JkZWxpbTogPExTVEFSVD4gImBgYCIhIDsKY29kZWJsb2NrOiA8Y2JkZWxpbT4hIDxjb2RlbWV0YT4gPGNvZGVib2R5PiA8RE5MMT4gOwpjb2RlbWV0YTogLig_KzxOTD4hKSA9PiBqb2luIDsKY29kZWJvZHk6IC4oPys8Y2JkZWxpbT4pID0-IGpvaW4gOwoKY3VzdG9tZGVsaW06IDxMU1RBUlQ-ICI6OjoiISA7CmN1c3RvbWJsb2NrOiA8Y3VzdG9tZGVsaW0-ISA8Y3VzdG9tbWV0YT4gPGN1c3RvbWJvZHk-IDxETkwxPiA7CmN1c3RvbW1ldGE6IC4oPys8Tkw-ISkgPT4gam9pbiA7CmN1c3RvbWJvZHk6IC4oPys8Y3VzdG9tZGVsaW0-KSA9PiBqb2luIDsKCm1ldGFibG9jazogPExTVEFSVD4gInt7eyIhIDxtZXRhdHlwZT4gPG1ldGFib2R5PiA8RE5MMT4gOwptZXRhdHlwZTogPEFMUEhBX05VTT4rID0-IGpvaW4gOwptZXRhYm9keTogLig_KzxtZXRhZW5kPiEpID0-IGpvaW4gOwptZXRhZW5kOiAifX19IiA8TEVORD4gOwoKYnFsaW5lOiA8TFNUQVJUPiAiPiAiIQogICAgICAgICg8cmVmPiB8IDxpbWc-IHwgPGZucmVmPiB8IDxsaW5rPiB8IDxib2xkPiB8IDxpdGFsaWM-IHwgPHN0cmlrZT4gfCA8Y29kZT4gfCA8ZW1vamk-IHwgPGJvZHkxPikqIDxETkw-IDsKYnF1b3RlOiA8YnFsaW5lPisgPEROTDE-IDsKCnRkZWxpbTogKDxpbmxpbmVkZWxpbT4gfCAnfCcgKSA7CnRib2R5OiAuKD8tPHRkZWxpbT4hKSA9PiBqb2luIDsKdGNlbGw6IDxXUzA-ICg8cmVmPiB8IDxpbWc-IHwgPGZucmVmPiB8IDxsaW5rPiB8IDxib2xkPiB8IDxpdGFsaWM-IHwgPHN0cmlrZT4gfCA8Y29kZT4gfCA8ZW1vamk-IHwgPHRib2R5PiApKiAnfCchIDsKdHJvdzogPExTVEFSVD4gJ3wnISA8dGNlbGw-KD8rPEROTD4pIDsKdGFibGU6IDx0cm93PisgPEROTDE-IDsKCmhyOiAiLS0iICgnLScoPy08Tkw-ISkpKiA8RE5MMT4gPT4gam9pbiA7CgptYWluOiA8V1MwPiAoPGhkPiB8IDxsaXN0PiB8IDxicXVvdGU-IHwgPGNvZGVibG9jaz4gfCA8Y3VzdG9tYmxvY2s-IHwgPG1ldGFibG9jaz4gfCA8dGFibGU-IHwgPGhyPiB8IDxmbm90ZT4gfCA8bGlua2RlZj4gfCA8cGFyYT4pKiA7pG1haW7aAgMjIEhlbGxvIDp3b3JsZDpbXjFdCgo6c21pbGU6Cgo6OjphbGVydApUZXN0IFtsYWJlbF1bcmVmcmVmXQo6OjoKCi0tLQoKe3t7anNvbiB7ImlkIjogMTIzLCAicHJvdGVjdGVkIjogdHJ1ZSB9IH19fQpTbyBbW3NtaWxlX2ZvbzEyXV0g8J-YjSB3aGF0J3MgW3RoaXNdKC4vdGhpcy5tZClbXjFdIHRoZW46CgpBIFtsaW5rIHdpdGggcmVmZXJlbmNlXVtyZWZyZWZdLi4uCgpbXjFdOiBGb28gYmFyIGJhegoKOnNtaWxlOgoKYGBgdHMgdGFuZ2xlOm5vIGxuOnllcwpjb25zdCBmb28gPQoKYGBgCgoxLiBmb28KICAyMy4gYmFyCiAgICAgYmF6IGFuZCBzbyBvbgogICAgIG11bHRpbGluZQoyLiBiYXJycnIKCj4gYmxvY2txdW90ZQo-IG11bHRpbGluZSB0b28KPiAtLSBzb3VyY2UKCnwgZm9vIHwgYmFyIHwKfDotfC06fAp8IFtbcmVmIzIyXV0gfCBgb25gICoqb2ZmKiogfAoKW14xXTogRm9vIF9iYXJfIGJhegoKW14yXTogVE9ETwoKW3JlZnJlZl06IGh0dHA6Ly90aGkubmcvCltmb29dOiAuL2Zvby5tZCNiYXIKCtktMTEuIGFiYwogIC0geHl6CjIxLiB4eHgKICAxLiBmb28KICAgIDEuIGJhcgoK2SZ7e3t5YW1sCi0gZm9vCi0gYmFyCiAgLSBiYXoKfX19ClRlc3QKCg

import type { Fn3, IObjectOf } from "@thi.ng/api";
import { peek } from "@thi.ng/arrays/peek";
import { DEFAULT, defmulti } from "@thi.ng/defmulti";
import { EMOJI } from "@thi.ng/emoji/emoji";
import type { ContextOpts, ParseScope } from "@thi.ng/parse";
import { defContext } from "@thi.ng/parse/context";
import { defGrammar } from "@thi.ng/parse/grammar";

export const GRAMMAR = defGrammar(`
DNL1: <DNL>+ => discard ;
DNL2: <NL>{2,} ;
inlinedelim: ( "![" | '[' | "**" | '_' | "~~" | '\`' | " :" ) ;
delim: ( <inlinedelim> | <DNL2> ) ;
delim1: ( <inlinedelim> | <NL> ) ;
body: .(?-<delim>!) => join ;
body1: .(?-<delim1>!) => join ;

ref: "[["! .(?+"]]"!) => join ;
fnref: "[^"! <uint> "]"! ;
fnote: <LSTART> "[^"! <uint> "]:"! <WS1> <para> ;
label: .(?+']'!) => join ;
target: .(?+')'!) => join ;
link: '['! <label> '('! <target> ;
linkref: '['! <label> '['! <label> ;
linkdef: <LSTART> '['! <label> ':'! <WS1> <ldtarget> ;
ldtarget: .(?+<DNL1>) => join ;
img: "!["! <label> '('! <target> ;
bold: "**"! .(?+"**"!) => join ;
italic: "_"! .(?+"_"!) => join ;
code: '\`'! .(?+'\`'!) => join ;
strike: "~~"! .(?+"~~"!) => join ;
emoji: ' '? ':'! <ALPHA_NUM>(?+':'!) => join ;
para: (<ref> | <img> | <fnref> | <linkref> | <link> | <bold> | <italic> | <strike> | <code> | <emoji> | <body>)* <DNL2>! ;

hdlevel: '#'+ => count ;
hd: <LSTART> <hdlevel> <WS0>
    (<ref> | <img> | <fnref> | <link> | <bold> | <italic> | <strike> | <code> | <emoji> | <body1> )* <DNL1> ;

lilevel: ' '* => count ;
uint: <DIGIT>+ => int ;
ulid: <DNL> <WS0> '-'! ;
olid: <DNL> <WS0> <DIGIT>+! '.'! ;
lidelim: ( <delim> | <ulid> | <olid> ) ;
libody: .(?-<lidelim>!) => join ;
todo: '['! [ xX] ']'! <WS1> => hoistR ;
ulitem: <LSTART> <lilevel> "- "! <todo>?
        (<ref> | <img> | <fnref> | <link> | <bold> | <italic> | <strike> | <code> | <emoji> | <libody> )* <DNL> ;
olitem: <LSTART> <lilevel> <uint> ". "! <todo>?
        (<ref> | <img> | <fnref> | <link> | <bold> | <italic> | <strike> | <code> | <emoji> | <libody> )* <DNL> ;
list: (<ulitem> | <olitem>)+ <DNL1> ;

cbdelim: <LSTART> "\`\`\`"! ;
codeblock: <cbdelim>! <codemeta> <codebody> <DNL1> ;
codemeta: .(?+<NL>!) => join ;
codebody: .(?+<cbdelim>) => join ;

customdelim: <LSTART> ":::"! ;
customblock: <customdelim>! <custommeta> <custombody> <DNL1> ;
custommeta: .(?+<NL>!) => join ;
custombody: .(?+<customdelim>) => join ;

metablock: <LSTART> "{{{"! <metatype> <metabody> <DNL1> ;
metatype: <ALPHA_NUM>+ => join ;
metabody: .(?+<metaend>!) => join ;
metaend: "}}}" <LEND> ;

bqline: <LSTART> "> "!
        (<ref> | <img> | <fnref> | <link> | <bold> | <italic> | <strike> | <code> | <emoji> | <body1>)* <DNL> ;
bquote: <bqline>+ <DNL1> ;

tdelim: (<inlinedelim> | '|' ) ;
tbody: .(?-<tdelim>!) => join ;
tcell: <WS0> (<ref> | <img> | <fnref> | <link> | <bold> | <italic> | <strike> | <code> | <emoji> | <tbody> )* '|'! ;
trow: <LSTART> '|'! <tcell>(?+<DNL>) ;
table: <trow>+ <DNL1> ;

hr: "--" ('-'(?-<NL>!))* <DNL1> => join ;

main: <WS0> (<hd> | <list> | <bquote> | <codeblock> | <customblock> | <metablock> | <table> | <hr> | <fnote> | <linkdef> | <para>)* ;
`);

export const parseRaw = (src: string, opts?: Partial<ContextOpts>) => {
	const ctx = defContext(src, opts);
	return { result: GRAMMAR!.rules.main(ctx), ctx };
};

export interface TagTransforms {
	bold(body: string): any;
	bquote(body: any[], meta?: any): any;
	code(body: string): any;
	custom(kind: string, body: string, meta?: any): any;
	emoji(id: string): any;
	hd(level: number, body: any[], meta?: any): any;
	hr(lenght: number): any;
	italic(body: string): any;
	link(target: string, body: any[]): any;
	ol(items: any[], meta?: any): any;
	olitem(attribs: TodoAttribs, index: number, ...body: any[]): any;
	para(body: any[], meta?: any): any;
	strike(body: string): any;
	ul(items: any[], meta?: any): any;
	ulitem(attribs: TodoAttribs, ...body: any[]): any;
}

export interface MDParseContext {
	tags: TagTransforms;
	linkRefs: IObjectOf<string>;
	fnRefs: IObjectOf<string>;
	meta?: any;
}

export type TodoAttribs = Partial<{ __todo: true; __done: boolean }>;

export const defMDContext = (tags: Partial<TagTransforms>): MDParseContext => ({
	linkRefs: {},
	fnRefs: {},
	meta: null,
	tags: {
		bold: (body) => ["strong", {}, body],
		bquote: (body, meta) => ["blockquote", __withMeta({}, meta), ...body],
		code: (body) => ["code", {}, body],
		custom: (kind, body, meta) => [kind, __withMeta({}, meta), body],
		emoji: (id) => EMOJI[id] || id,
		hd: (level, body, meta) => [`h${level}`, __withMeta({}, meta), ...body],
		hr: (__length) => ["hr", { __length }],
		italic: (body) => ["em", {}, body],
		link: (href, body) => ["a", { href }, ...body],
		olitem: (attribs, index, body) => [
			"li",
			{ ...attribs, __index: index },
			...body,
		],
		ol: (items, meta) => ["ol", __withMeta({}, meta), ...items],
		para: (body, meta) => ["p", __withMeta({}, meta), ...body],
		strike: (body) => ["s", {}, body],
		ul: (items, meta) => ["ul", __withMeta({}, meta), ...items],
		ulitem: (attribs, body) => ["li", attribs, ...body],
		...tags,
	},
});

const __withMeta = (target: any, meta?: any) => {
	if (meta != null) {
		target.__meta = meta;
	}
	return target;
};

export const walk: Fn3<
	ParseScope<string>,
	MDParseContext,
	any[],
	void
> = defmulti<ParseScope<string>, MDParseContext, any[], void>(
	(x) => {
		console.log(x);
		return x.id;
	},
	{
		body1: "body",
		bqline: "repeat0",
		libody: "body",
		main: "root",
		repeat1: "repeat0",
	},
	{
		[DEFAULT]: (scope: ParseScope<string>, ctx: MDParseContext) => {
			throw new Error(
				`unknown ID: ${scope.id}, ctx: ${JSON.stringify(ctx)}`
			);
		},

		root: (scope, ctx, acc) => walk(scope.children![0], ctx, acc),

		repeat0: (scope, ctx, acc) => {
			for (let c of scope.children!) walk(c, ctx, acc);
		},

		body: (scope, _, acc) => acc.push(scope.result),

		bold: (scope, ctx, acc) => acc.push(ctx.tags.bold(scope.result)),

		bquote: (scope, ctx, acc) => {
			const body: any[] = [];
			const children = scope.children![0].children!;
			for (let i = 0, n = children!.length - 1; i <= n; i++) {
				walk(children[i].children![0], ctx, body);
				// TODO add opt to customize break (e.g. ["br"] vs " ")
				if (i < n) body.push(" ");
			}
			acc.push(ctx.tags.bquote(body, ctx.meta));
			ctx.meta = null;
		},

		code: (scope, ctx, acc) => acc.push(ctx.tags.code(scope.result)),

		customblock: ({ children }, ctx, acc) => {
			acc.push(
				ctx.tags.custom(
					children![0].result,
					children![1].result.trim(),
					ctx.meta
				)
			);
			ctx.meta = null;
		},

		emoji: ({ result }, ctx, acc) => {
			if (result[0] === " ") {
				acc.push(" ");
				result = result.substring(1);
			}
			acc.push(ctx.tags.emoji(result));
		},

		hd: ({ children }, ctx, acc) => {
			const body: any[] = [];
			walk(children![1], ctx, body);
			acc.push(ctx.tags.hd(children![0].result, body, ctx.meta));
			ctx.meta = null;
		},

		hr: (scope, ctx, acc) => acc.push(ctx.tags.hr(scope.result.length)),

		italic: (scope, ctx, acc) => acc.push(ctx.tags.italic(scope.result)),

		link: (scope, ctx, acc) => {
			const body: any[] = [];
			walk(scope.children![0], ctx, body);
			acc.push(ctx.tags.link(scope.children![1].result, body));
		},

		list: (scope, ctx, acc) => {
			const children = scope.children![0].children!;
			const stack: any[][] = [
				[children[0].id === "ulitem" ? "ul" : "ol"],
			];
			const levels = [0];
			for (let item of children) {
				const currLevel = item.children![0].result;
				if (currLevel > peek(levels)) {
					const sublist = [item.id === "ulitem" ? "ul" : "ol"];
					const parent = peek(stack);
					parent.length > 1
						? peek(parent).push(sublist)
						: parent.push([
								parent[0] === "ul" ? "ulitem" : "olitem",
								{},
								sublist,
						  ]);
					stack.push(sublist);
					levels.push(currLevel);
				} else if (currLevel < peek(levels)) {
					while (currLevel < peek(levels)) {
						stack.pop();
						levels.pop();
					}
				}
				walk(item, ctx, peek(stack));
			}

			const $list = (root: any[], isTop = false) =>
				ctx.tags[<"ul" | "ol">root[0]](
					root.slice(1).map($item),
					isTop ? ctx.meta : null
				);

			const $item = (item: any[]) => {
				let last = item[item.length - 1];
				if (last[0] === "ul" || last[0] === "ol")
					item[item.length - 1] = $list(last);
				return item[0] === "ulitem"
					? ctx.tags.ulitem(item[1], item.slice(2))
					: ctx.tags.olitem(item[1], item[2], item.slice(3));
			};

			acc.push($list(stack[0], true));
			ctx.meta = null;
		},

		metablock: ({ children }, ctx) => {
			ctx.meta = {
				type: children![0].result,
				body: children![1].result.trim(),
			};
		},

		olitem: (scope, ctx, acc) => {
			const body: any[] = [];
			walk(scope.children![3], ctx, body);
			acc.push([
				"olitem",
				__listItemAttribs(scope.children![2]),
				scope.children![1].result,
				...body,
			]);
		},

		para: (scope, ctx, acc) => {
			const body: any[] = [];
			for (let c of scope.children!) walk(c, ctx, body);
			acc.push(ctx.tags.para(body, ctx.meta));
			ctx.meta = null;
		},

		strike: (scope, ctx, acc) => acc.push(ctx.tags.strike(scope.result)),

		ulitem: (scope, ctx, acc) => {
			const body: any[] = [];
			walk(scope.children![2], ctx, body);
			acc.push([
				"ulitem",
				__listItemAttribs(scope.children![1]),
				...body,
			]);
		},
	}
);

const __listItemAttribs = (scope?: ParseScope<string>): TodoAttribs =>
	scope?.id === "todo"
		? {
				__todo: true,
				__done: scope.result === "x",
		  }
		: {};
